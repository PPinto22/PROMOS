# control bloat by varying the probabilities of removal/addition of neurons and connections in the population
[mutations]
# how to measure bloat
# time: evaluation+evolution time in seconds by generation
# connections: average number of connections by generation
bloat_type = connections

# start simplifying above this limit (either seconds or #connections, according to ${limit_by})
upper_limit = 120

# reset to default mutations values below this limit (either seconds or #connections, according to ${limit_by})
# optional -- default=${upper_limit}
lower_limit = 100

# increase/decrease the probability of removing/adding a neuron by this amount when in simplifying phase
mut_neurons_delta = 0.0005

# increase/decrease the probability of removing/adding a connections by this amount when in simplifying phase
mut_connections_delta = 0.001

# update every ${frequency} generations
# optional -- default=1
frequency = 1

# control bloat by adjusting each individual's fitness:
# fitness_adjusted = fitness/penalization(bloat)
#[fitness]
# how to measure bloat
# time: evaluation time in MICROSECONDS 
# connections: network connections
#bloat_type = connections

# the shape of the penalty function: step, [...TODO]
#penalty_function = step

# start penalizing fitness for bloat values above this limit
#lower_limit = 5

# the x-axis width of each step
# applicable if function == step
#step_width = 5

# each step, increase the penalty multiplier by this ammount
# applicable if function == step
#step_penalty_increase = 0.1



