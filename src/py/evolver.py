#!/usr/bin/python3

import MultiNEAT as neat
import argparse
import csv
import datetime
import json
import math
import os
import random
from functools import partial

import tabulate
from reprint import reprint, output
from sortedcontainers import SortedListWithKey

tabulate.PRESERVE_WHITESPACE = True
from tabulate import tabulate

import params
from encoder import Encoder
from evaluator import Evaluator, FitFunction
import util
import bloat
from util import avg
import substrate as subst
from data import Data, SlidingWindow


def parse_args():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('data_file', help='path to train data file', metavar='DATA'),
    parser.add_argument('-t', '--test', dest='test_file', default=None,
                        help='path to test data file', metavar='FILE')
    parser.add_argument('-o', '--outdir', dest='out_dir', default='.',
                        help='directory where to save results. If NULL, do not save results.', metavar='DIR')
    methods = ['neat', 'hyperneat']
    parser.add_argument('-m', '--method', dest='method', choices=methods, default='neat',
                        help='which algorithm to run: ' + ', '.join(methods), metavar='M')
    parser.add_argument('-P', '--params', dest='params', metavar='FILE', default=None,
                        help='path to a parameters file. If not specified, default values will be used.')
    parser.add_argument('-x', '--substrate', dest='substrate', metavar='X', default=0,
                        type=partial(util.range_int, lower=0, upper=len(subst.substrates) - 1),
                        help='which substrate to use, 0 <= X <= {}'.format(len(subst.substrates) - 1))
    parser.add_argument('--substrate-width', dest='substrate_width', metavar='N', default=13, type=util.uint,
                        help='how many layers the grid substrate should have')
    parser.add_argument('--substrate-length', dest='layer_length', metavar='M', default=45, type=util.uint,
                        help='how many neurons each layer of the grid substrate should have')
    parser.add_argument('-e', '--evaluator', dest='evaluator', choices=FitFunction.list(), default='auc',
                        help='evaluation function: ' + ', '.join(FitFunction.list()), metavar='E')
    parser.add_argument('-E', '--encoder', dest='encoder', metavar='FILE', default=None,
                        help='configuration file for numeric encoding. The encoding is performed over the training'
                             'data-set only. The test data-set is generated by mapping its raw'
                             'values to the corresponding codification in the training data-set')
    parser.add_argument('-g', '--generations', dest='generations', type=util.uint, metavar='G', default=None,
                        help='number of generations per run or, if the option -W is specified, per sliding window')
    parser.add_argument('-T', '--time', dest='time_limit', type=util.uint, metavar='MIN', default=None,
                        help='time limit (in minutes) per run or, if the option -W is specified, per sliding window')
    parser.add_argument('-p', '--processes', dest='processes', type=util.uint, default=1,
                        help='number of processes to use for parallel evaluation. '
                             'If P=1, the evaluations will be sequential', metavar='P')
    parser.add_argument('-s', '--sample', dest='sample_size', type=util.uint, default=0, metavar='N',
                        help='use a balanced sample of size N in evaluations. If S=0, use the whole data-set')
    parser.add_argument('-l', '--load', dest='pop_file', metavar='FILE', default=None,
                        help='load the contents of FILE as the initial population and parameters')
    parser.add_argument('-r', '--resume', dest='progress_file', metavar='FILE', default=None,
                        help='resume execution from the progress FILE')
    parser.add_argument('-R', '--runs', dest='runs', metavar='R', help='run R times', type=util.uint, default=1)
    parser.add_argument('-q', '--quiet', dest='quiet', action='store_true',
                        help='Do not print any messages to stdout, except for the result')
    parser.add_argument('--no-reprint', dest='reprint', action='store_false',
                        help='print output messages sequentially')
    parser.add_argument('--id', dest='id', metavar='ID', default=None,
                        help='run identifier. This ID will be used to name all output files '
                             '(e.g., ID_summary.txt). '
                             'If unspecified, the ID will be the datetime of when the run was started.')
    parser.add_argument('--seed', dest='seed', metavar='S', type=util.uint, default=None,
                        help='specify an RNG integer seed')
    parser.add_argument('--test-fitness', dest='test_fitness', action='store_true',
                        help='evaluate every individual with a sample (of size N=sample_size) of the test data-set. '
                             'These evaluations are for validation only, and have no influence over the evolutionary'
                             ' process. This option slows down the execution speed by half.')
    parser.add_argument('--no-statistics', dest='no_statistics', action='store_true',
                        help='do not record any statistics regarding the progress of individuals over time')
    parser.add_argument('--no-reevaluation', dest='no_reevaluation', action='store_true',
                        help='applicable if a sample size is specified. '
                             'If set, there will be no final reevaluation of '
                             'the best individuals with the whole data-set.')
    parser.add_argument('-W', '--window', dest='width', metavar='W', type=util.uint, default=None,
                        help='Sliding window width (train + test) in hours')
    parser.add_argument('-w', '--test-window', dest='test_width', metavar='W', type=util.uint, default=None,
                        help='Test sliding window width in hours')
    parser.add_argument('-S', '--shift', dest='shift', metavar='S', type=util.uint, default=None,
                        help='Sliding window shift in hours')
    parser.add_argument('-b,' '--bloat', dest='bloat_file', metavar='FILE', default=None,
                        help='configuration file for limiting the effects of bloat')

    options = parser.parse_args()

    options.id = options.id if options.id is not None else util.get_current_datetime_string()
    options.out_dir = options.out_dir if options.out_dir != 'NULL' else None

    if options.seed is not None:
        random.seed(options.seed)

    return options


class Summary:
    class Best:
        def __init__(self, eval, test, network=None):
            self.fitness = eval.fitness
            self.fitness_test = test
            if network is not None:
                self.connections = util.get_network_connections(network)
                self.neurons = util.get_network_neurons(network)
                self.neurons_qty = len(self.neurons)
                self.connections_qty = len(self.connections)

    def __init__(self, best_eval, fitness_test, best_network=None, **other_info):
        self.best = Summary.Best(best_eval, fitness_test, best_network)
        for key, value in other_info.items():
            self.__setattr__(key, value)


class Evolver:
    def __init__(self, options, printer=None):
        self.options = options

        # Sliding window assertions
        assert not all(x is not None for x in (self.options.test_file, self.options.test_width)), \
            'Either specify a static test file (-t) or a test sliding window width (-w); not both'
        assert all(x is not None for x in (self.options.width, self.options.shift)) or \
               not any(x is not None for x in (self.options.width, self.options.shift)), \
            'Both window width (-W) and window shift (-S) are required'
        if self.options.test_width is not None:
            assert self.options.width is not None, 'The test width option (-w) requires the window width option (-W)'

        # Evaluation function
        self.fitness_func = FitFunction(self.options.evaluator)

        # MultiNEAT parameters
        self.params = params.get_params(self.options.params)

        # Bloat options
        self.bloat_options = bloat.BloatOptions(self.options.bloat_file) \
            if self.options.bloat_file is not None else None
        self.mutation_rate_controller = bloat.MutationRateController(self.params, self.bloat_options.mutation_options) \
            if bloat.BloatOptions.has_mutation_options(self.bloat_options) else None
        self.fitness_adjuster = bloat.FitnessAdjuster(self.bloat_options.fitness_options) \
            if bloat.BloatOptions.has_fitness_options(self.bloat_options) else None

        # Sliding window
        self.width = self.options.width if self.options.width is not None else 0
        self.test_width = self.options.test_width if self.options.test_width is not None else 0
        self.shift = self.options.shift if self.options.shift is not None else 0
        self.is_online = self.options.width is not None  # Is sliding window being used
        self.slider = SlidingWindow(self.width, self.shift, self.test_width, file_path=self.options.data_file) \
            if self.is_online else None
        self.n_inputs_diff = 0  # How many existing input columns changed since the last window
        self.inputs_diff = []  # List of tuples of columns which have been replaced (old_input, new_input)
        self.n_inputs_delta = 0  # Difference of inputs between he current window and the previous one
        self.inputs_new = []  # Names on new inputs which have not replaced any existing ones
        self.windows_best = []  # Best results of every window (List of tuples)
        self.windows_final_gens = []  # List of generations when each window ended

        # Timers, counters and other auxiliary variables
        self.run_i = None  # Current run, in case of multiple runs
        self.generation = 0  # Current generation
        # All time best evaluations, ordered from best to worst fitness
        self.best_list = SortedListWithKey(key=lambda x: -x.fitness)
        self.best_set = set()  # Set of IDs of the individuals in best_list
        self.best_test = None  # GenomeEvaluation (evaluated with the test data-set) of the best individual in best_test
        self.initial_time = None  # When the run started
        self.window_initial_time = None  # When the current window started
        self.gen_initial_time = None  # When the current generation started
        self.eval_time = None  # Time spent in evaluations
        self.window_eval_time = None  # Time spent in evaluations during the current window
        self.gen_eval_time = None  # Time spent in evaluations during the current generation
        self.ea_time = None  # Time spent in the EA
        self.window_ea_time = None  # Time spent in the EA during the current window
        self.gen_ea_time = None  # Time spent in the EA during the current generation
        self.evaluations = None  # List of the latest population evaluations
        if printer is None and not self.options.quiet:
            self.reprint_obj = output(initial_len=0)
            self.reprint_obj.no_warning = True
            self.printer = self.reprint_obj.__enter__()
        else:
            self.reprint_obj = None
            self.printer = printer
        self.state_lines = 0  # How many output lines are required for the current state
        self.state_header = []  # Header for the current state table
        self.top10_lines = 0  # How many output lines are required for the top 10
        self.top10_header = []  # Header for the top 10 evaluations
        self.windows_lines = 0  # How many output lines are required for the windows table
        self.windows_header = []  # Header for the windows best table

        # Encoding and load progress
        self.mapping = None
        self.encoder = Encoder(self.options.encoder) if self.options.encoder is not None else None
        if self.options.progress_file is not None:
            self.output_update_state('Resuming', pre=True)
            self.load_progress(self.options.progress_file)
        # Data
        self.output_update_state('Preparing data', pre=True)
        self._setup_data()

        # Substrate for HyperNEAT
        self.substrate = self._init_substrate()

        self._keep_timers = False
        self.init_timers()
        self.pop = self.init_population()  # C++ Population
        if self.mutation_rate_controller is not None:
            self.mutation_rate_controller.set_params(self.params)

    def _setup_data(self, window=None):
        if window is not None:
            self.train_data, test_data = self.slider.get_window_data(window, update_state=True)
            self.test_data = Data(self.options.test_file) if self.options.test_file is not None else test_data
        else:
            if self.is_online:  # Set the first window
                if self.slider._window == 0 and not self.slider.has_next():
                    raise AttributeError('The specified window width (-W) is too large for the available data')
                if self.slider.has_next():
                    self.train_data, test_data = next(self.slider)
                    self.test_data = Data(self.options.test_file) if self.options.test_file is not None else test_data
            else:  # Use static data
                self.train_data = Data(self.options.data_file)
                self.test_data = Data(self.options.test_file) if self.options.test_file is not None else None
        if self.encoder is not None:
            self.encode_data()
        self.setup_evaluator()

    def _init_substrate(self):
        try:
            substrate = subst.get_substrate(self.options.substrate,
                                            inputs=self.train_data.n_inputs,
                                            hidden_layers=self.options.substrate_width,
                                            nodes_per_layer=[self.options.layer_length] * self.options.substrate_width,
                                            outputs=1) \
                if self.options.method in ['hyperneat', 'eshyperneat'] else None
            return substrate
        except IndexError:
            raise ValueError('Invalid substrate choice: {} (should be 0 <= X <= {})'.
                             format(self.options.substrate, len(subst.substrates) - 1)) from None

    def encode_data(self, soft_order=None):
        self.mapping = self.train_data.encode(self.encoder, soft_order=soft_order)
        if self.test_data is not None:
            self.test_data.encode_from_mapping(self.mapping)

    def setup_evaluator(self):
        Evaluator.setup(self.train_data, self.test_data, processes=self.options.processes)

    def clear(self):
        self.initial_time = None
        self.window_initial_time = None
        self.eval_time = None
        self.window_eval_time = None
        self.gen_eval_time = None
        self.ea_time = None
        self.window_ea_time = None
        self.gen_ea_time = None
        if self.is_online:
            self.slider.reset()
            self.train_data, test = next(self.slider)
            if self.test_width is not None:
                self.test_data = test
        self.run_i = None
        self.pop = self.init_population()
        self.generation = 0
        self.best_list.clear()
        self.best_set.clear()
        self.best_test = None
        if self.mutation_rate_controller is not None:
            self.mutation_rate_controller.reset()

    def load_pop(self, file_path):
        try:
            self.pop = neat.Population(file_path)
        except RuntimeError:
            raise AttributeError('Invalid population file \'{}\''.format(file_path))
        self.params = self.pop.Parameters
        return self.pop


    def init_population(self):
        if self.options.pop_file is not None:
            return self.load_pop(self.options.pop_file)

        output_act_f = neat.ActivationFunction.UNSIGNED_SIGMOID
        hidden_act_f = neat.ActivationFunction.UNSIGNED_SIGMOID
        seed = random.randint(0, 2147483647) if self.options.seed is None else self.options.seed

        if self.options.method in ['hyperneat', 'eshyperneat']:
            g = neat.Genome(0, self.substrate.GetMinCPPNInputs(), 0, self.substrate.GetMinCPPNOutputs(),
                            False, output_act_f, hidden_act_f, 0, self.params, 0)
            pop = neat.Population(g, self.params, True, 1.0, seed)
        else:
            g = neat.Genome(0, self.train_data.n_inputs, 0, 1, False, output_act_f, hidden_act_f, 0,
                            self.params, 0)
            pop = neat.Population(g, self.params, True, 1.0, seed)

        return pop

    def get_genome_list(self):
        return [individual for species in self.pop.Species for individual in species.Individuals]

    def elapsed_time(self):
        return datetime.datetime.now() - self.initial_time if self.initial_time is not None else None

    def window_elapsed_time(self):
        return datetime.datetime.now() - self.window_initial_time if self.window_initial_time is not None else None

    def generation_elapsed_time(self):
        return datetime.datetime.now() - self.gen_initial_time if self.gen_initial_time is not None else None

    def is_finished(self):
        if not self.is_online:
            return self.is_window_finished()  # Assuming no sliding window as equivalent to a single window
        else:
            return not self.slider.has_next() and self.is_window_finished()

    def output_update_state(self, state, pre=False):
        if self.options.quiet:
            return

        if not self.state_header:
            self.state_header += ['Current task', 'Run Time', 'Generation']
            self.state_header += ['Window'] if self.is_online else []
            self.state_header += ['ID']
        state = [state.ljust(15), self._get_time_state(pre), self._get_generation_state(pre)]
        state += [self._get_window_state(pre)] if self.is_online else []
        state += [self.options.id]
        table = tabulate([state], headers=self.state_header).split('\n')

        self.print(' ', i=0)
        self.print('[STATUS]', i=1)
        for i, line in enumerate(table):
            self.print(line, i=i + 2)
        self.state_lines = len(table) + 2

    def print_top10(self):
        if not self.top10_header:
            self.top10_header = ['Rank', 'ID', 'Spawn Gen', 'Fitness (Train)']
            if self.bloat_options is not None:
                self.top10_header += ['Fitness (Adj)']
            self.top10_header += ['Fitness (Test)', 'Hidden Neurons', 'Connections']

        start = self.state_lines
        self.print(' ', i=start)
        self.print('[TOP 10]', i=start + 1)
        top10 = [(i + 1, e.genome_id, e.spawn_gen + 1, e.fitness, e.fitness_adj, e.fitness_test, e.genome_neurons,
                  e.genome_connections) for i, e in enumerate(self.best_list[:10])]
        if self.bloat_options is None:
            # Remove adjusted fitness
            top10 = [(e[0], e[1], e[2], e[3], e[5], e[6], e[7]) for e in top10]

        table = tabulate(top10, self.top10_header, floatfmt='.5f').split('\n')
        for i, line in enumerate(table):
            self.print(line, i=start + 2 + i)
        self.top10_lines = len(table) + 2

    def print_windows_best(self):
        if not self.is_online:
            return
        if not self.windows_header:
            self.windows_header = ['Window', 'ID', 'Spawn Gen', 'Total Gens',
                                   'Fitness (Train)', 'Fitness (Test)', 'Hidden Neurons', 'Connections']

        start = self.state_lines + self.top10_lines
        self.print(' ', i=start)
        self.print('[BEST RESULTS]', i=start + 1)
        table = tabulate(self.windows_best, self.windows_header, floatfmt='.5f').split('\n')
        for i, line in enumerate(table):
            self.print(line, i=start + 2 + i)
        self.windows_lines = len(table) + 2

    def _get_time_state(self, pre=False):
        if pre:
            return ''
        elapsed_time = self.elapsed_time()
        elapsed_str = str(elapsed_time).split('.')[0] if elapsed_time is not None else ''
        shift = str(self.window_initial_time - self.initial_time
                    + datetime.timedelta(minutes=self.options.time_limit)).split('.')[0] \
            if self.options.time_limit is not None else None
        shift_str = ' / {}'.format(shift) if shift is not None else ''
        return elapsed_str + shift_str

    def _get_generation_state(self, pre=False):
        if pre:
            return ''
        cur_gen = str(self.generation)
        shift = self.get_current_window() * self.options.generations + self.options.generations if \
            self.options.generations is not None else None
        shift_str = ' / {}'.format(shift) if shift is not None else ''
        return cur_gen + shift_str

    def _get_window_state(self, pre=False):
        if pre:
            return ''
        if not self.is_online:
            return None
        return '{} / {}'.format(self.get_current_window() + 1, self.slider.n_windows)

    def print(self, msg, i=None, override=False):
        if override:
            print(msg)
        else:
            if not self.options.quiet:
                if i is None or i >= len(self.printer):
                    self.printer.append(msg)
                else:
                    self.printer[i] = msg

    def make_out_dir(self):
        if self.options.out_dir is None:
            raise ValueError('out_dir is None')

        util.make_dir(self.options.out_dir)

    def get_out_file_path(self, suffix, include_window=True):
        if self.options.out_dir is None:
            raise ValueError('out_dir is None')

        run = '({})'.format(self.run_i) if self.run_i is not None else ''
        window = '({})'.format(self.get_current_window()) if include_window and self.is_online else ''

        # Format: '<OUTDIR>/<ID><(RUN_INDEX)><(WINDOW_INDEX)>_<SUFFIX>
        # Example: 'results/sample1K(0)(0)_summary.json'
        return '{}/{}{}{}_{}'.format(self.options.out_dir, self.options.id, run, window, suffix)

    def write_results(self):
        if self.options.out_dir is not None:
            self.make_out_dir()
            self.save_window_summary()
            self.write_summary(self.get_out_file_path('summary.json'))
            self.pop.Save(self.get_out_file_path('population.txt'))
            self.get_best().genome.Save(self.get_out_file_path('best.txt'))

    def save_progress(self):
        if self.options.out_dir is None:
            return
        self.make_out_dir()
        with open(self.get_out_file_path('progress.txt', include_window=False), 'w') as file:
            self.encoder is not None and file.write(
                'encoder {}\n'.format(os.path.abspath(self.get_out_file_path('encoder.bin', include_window=False))))
            file.write('population {}\n'.format(os.path.abspath(self.get_out_file_path('population.txt'))))
            self.run_i is not None and file.write('run {}\n'.format(self.run_i))
            self.is_online and file.write('window {}\n'.format(self.get_current_window()))
            file.write('generation {}\n'.format(self.generation))
            file.write('time {}\n'.format(self.elapsed_time().total_seconds()))
            file.write('ea_time {}\n'.format(self.ea_time.total_seconds()))
            file.write('eval_time {}\n'.format(self.eval_time.total_seconds()))

    def save_encoder(self):
        if self.options.out_dir is None:
            return
        self.make_out_dir()
        self.encoder is not None and self.encoder.save(self.get_out_file_path('encoder.bin', include_window=False))

    def save_mapping(self):
        if self.options.out_dir is None:
            return
        self.make_out_dir()
        self.mapping is not None and self.mapping.save(self.get_out_file_path('mapping.bin'))

    def load_progress(self, file_path):
        self.output_update_state('Resuming')
        with open(file_path, 'r') as file:
            for line in file:
                line = line.strip('\n')
                key, value = line.split()[0], line.split()[1]
                if key == 'run':
                    self.run_i = int(value)
                elif key == 'window':
                    self._setup_data(window=int(value))
                elif key == 'generation':
                    self.generation = int(value)
                elif key == 'time':
                    self.initial_time = datetime.datetime.now() - datetime.timedelta(seconds=float(value))
                elif key == 'ea_time':
                    self.ea_time = datetime.timedelta(seconds=float(value))
                elif key == 'eval_time':
                    self.eval_time = datetime.timedelta(seconds=float(value))
                elif key == 'encoder':
                    self.encoder = Encoder.load(value)
                elif key == 'population':
                    self.load_pop(value)
        self._keep_timers = True
        self.output_update_state('Resuming')

    def get_summary(self):
        best_evaluation = self.get_best()
        net = util.build_network(best_evaluation.genome, self.options.method, self.substrate)
        date_begin, date_end = self.train_data.get_time_range()
        return Summary(
            best_eval=best_evaluation, best_network=net,
            fitness_test=self.best_test.fitness if self.best_test is not None else None,
            # Other info
            params=params.ParametersWrapper(self.params), generations=self.generation,
            run_time=datetime.datetime.now() - self.initial_time, eval_time=self.eval_time,

            ea_time=self.ea_time, processes=self.options.processes,
            sample_size=self.options.sample_size if self.options.sample_size is not None else len(self.train_data),
            window=self.get_current_window() if self.is_online else None,
            date_begin=date_begin, date_end=date_end, train_size=len(self.train_data),
            train_positives=len(self.train_data.positives), train_negatives=len(self.train_data.negatives),
            test_size=len(self.test_data) if self.test_data is not None else -1,
            test_positives=len(self.test_data.positives) if self.test_data is not None else -1,
            test_negatives=len(self.test_data.negatives) if self.test_data is not None else -1
        )

    def write_summary(self, file_path):
        with open(file_path, 'w', encoding='utf8') as f:
            f.write(json.dumps(self.get_summary().__dict__, default=util.serializer, indent=4))

    def save_window_summary(self):
        if not self.is_online or self.options.out_dir is None:
            return

        self.make_out_dir()
        file_path = self.get_out_file_path('windows.csv', include_window=False)
        if self.get_current_window() == 0:
            with open(file_path, 'w') as file:
                writer = csv.writer(file, delimiter=',')
                header = ['window', 'begin_date', 'end_date', 'generations', 'run_time', 'eval_time', 'ea_time',
                          'inputs', 'inputs_delta', 'n_inputs_diff', 'inputs_diff',
                          'train_size', 'train_positives', 'train_negatives',
                          'test_size', 'test_positives', 'test_negatives',
                          'train_fitness', 'test_fitness',
                          'best_neurons', 'best_connections', ]
                writer.writerow(header)
        with open(file_path, 'a') as file:
            writer = csv.writer(file, delimiter=',')
            test_size = len(self.test_data) if self.test_data is not None else -1
            test_positives = len(self.test_data.positives) if self.test_data is not None else -1
            test_negatives = len(self.test_data.negatives) if self.test_data is not None else -1
            test_fitness = self.best_test.fitness if self.best_test is not None else -1
            best = self.get_best()
            begin_date, end_date = self.train_data.get_time_range()
            writer.writerow([self.get_current_window(), begin_date, end_date, self.generation,
                             self.window_elapsed_time().total_seconds() / 60.0,
                             self.window_eval_time.total_seconds() / 60.0,
                             self.window_ea_time.total_seconds() / 60.0,
                             self.train_data.n_inputs, self.n_inputs_delta, self.n_inputs_diff, self.inputs_diff,
                             len(self.train_data), len(self.train_data.positives), len(self.train_data.negatives),
                             test_size, test_positives, test_negatives, best.fitness, test_fitness,
                             best.neurons, best.connections])

    def save_evaluations(self):
        if self.options.no_statistics or self.options.out_dir is None:
            return

        self.make_out_dir()
        file_path = self.get_out_file_path('evaluations.csv', include_window=False)
        if self.generation == 0:
            with open(file_path, 'w') as file:
                writer = csv.writer(file, delimiter=',')
                header = ['window', 'generation', 'genome_id', 'fitness', 'fitness_test', 'fitness_adj',
                          'genome_neurons', 'genome_connections', 'neurons', 'connections',
                          'build_time', 'pred_time', 'pred_avg_time', 'fit_time', 'run_time']
                writer.writerow(header)
        with open(file_path, 'a') as file:
            writer = csv.writer(file, delimiter=',')
            for e in self.evaluations:
                fitness_test = e.fitness_test if e.fitness_test is not None else -1
                writer.writerow([e.window, e.generation, e.genome_id, e.fitness, fitness_test, e.fitness_adj,
                                 e.genome_neurons, e.genome_connections, e.neurons, e.connections,
                                 e.build_time, e.pred_time, e.pred_avg_time, e.fit_time,
                                 e.global_time.total_seconds() / 60.0 if e.global_time is not None else None])

    def save_generation(self):
        if self.options.no_statistics or self.options.out_dir is None:
            return

        self.make_out_dir()
        file_path = self.get_out_file_path('generations.csv', include_window=False)
        if self.generation == 0:
            with open(file_path, 'w') as file:
                writer = csv.writer(file, delimiter=',')
                header = ['generation', 'eval_time', 'ea_time', 'run_time',
                          'add_neuron', 'rem_neuron', 'add_link', 'rem_link']
                writer.writerow(header)
        with open(file_path, 'a') as file:
            writer = csv.writer(file, delimiter=',')
            writer.writerow([self.generation, self.gen_eval_time.total_seconds(), self.gen_ea_time.total_seconds(),
                             self.generation_elapsed_time().total_seconds(),
                             self.params.MutateAddNeuronProb, self.params.MutateRemSimpleNeuronProb,
                             self.params.MutateAddLinkProb, self.params.MutateRemLinkProb])

    def get_best(self):
        return self.best_list[0]

    def update_best_list(self):
        # Penalize individuals older than 20 generations
        if self.generation % 20 == 0:
            for e in self.best_list:
                if e.generation < self.generation - 20:
                    e.fitness -= e.fitness * 0.01

        max_updates = math.ceil(0.05 * self.params.PopulationSize)  # Take at most the best 5% of evaluations
        # Evaluations must be sorted by descending fitness
        for i in range(max_updates):
            e = self.evaluations[i]
            # Break condition (best_list is full and e is worse than the worst evaluation in best_list)
            if len(self.best_list) == self.params.PopulationSize and e.fitness < self.best_list[-1].fitness:
                break
            elif e.genome_id in self.best_set:  # Individual already exists in best_list; update
                self._update_best_list_evaluation(e)
            else:  # Add to best_list
                self._add_to_best_list(e)
                # Cap the size of best_list at PopulationSize
                if len(self.best_list) > self.params.PopulationSize:
                    self._remove_from_best_list(-1)

    def _update_best_list_evaluation(self, new_eval):
        i = util.list_find(self.best_list, lambda e: e.genome_id == new_eval.genome_id)
        new_eval.spawn_gen = self.best_list[i].spawn_gen
        del self.best_list[i]
        self._add_to_best_list(new_eval)

    def _add_to_best_list(self, evaluation):
        evaluation.save_genome_copy()
        i = self.best_list.bisect_left(evaluation)
        self.best_list.insert(i, evaluation)
        self.best_set.add(evaluation.genome_id)
        return i

    def _remove_from_best_list(self, index):
        self.best_set.remove(self.best_list[index].genome_id)
        del self.best_list[index]

    def reevaluate_best_list(self):
        evaluation_list = self.evaluate_list([e.genome for e in self.best_list], sample_size=0, time=True)
        original_gens = [e.generation for e in self.best_list]
        self.best_list.clear()
        for i, e in enumerate(evaluation_list):
            e.generation = original_gens[i]
            self.best_list.add(e)

    def evaluate_list(self, genome_list, sample_size=None, adjuster=None, time=True):
        sample_size = sample_size if sample_size is not None else self.options.sample_size
        test_data = self.test_data if self.options.test_fitness and not self.options.no_statistics else None
        time_diff, evaluation_list = util.time(lambda: Evaluator.evaluate_genome_list(
            genome_list, self.fitness_func, data=self.train_data, sample_size=sample_size,
            test_data=test_data, adjuster=adjuster, method=self.options.method, substrate=self.substrate,
            generation=self.generation, window=self.get_current_window(), initial_time=self.initial_time
        ))

        if time:
            self.eval_time += time_diff
            self.window_eval_time += time_diff
            self.gen_eval_time = time_diff

        return evaluation_list

    def evaluate(self, genome):
        return self._evaluate(genome, self.train_data)

    def evaluate_test(self, genome):
        return self._evaluate(genome, self.test_data)

    def _evaluate(self, genome, data):
        return Evaluator.evaluate(genome, self.fitness_func, data, method=self.options.method,
                                  substrate=self.substrate, generation=self.generation,
                                  window=self.get_current_window(), initial_time=self.initial_time)

    def evaluate_pop(self):
        self.output_update_state('Evaluating')
        self.evaluations = self.evaluate_list(self.get_genome_list(), adjuster=self.fitness_adjuster, time=True)
        self.save_evaluations()
        self.update_best_list()

    def epoch(self):
        self.output_update_state('Evolving')
        time_diff, _ = util.time(self.pop.Epoch)

        self.ea_time += time_diff
        self.window_ea_time += time_diff
        self.gen_ea_time = time_diff

        self.save_generation()
        self.generation += 1

    def print_best(self):
        best = self.get_best()
        if not self.is_online:
            best_test_str = ' Fitness (test): {:.6f},'.format(
                self.best_test.fitness) if self.best_test is not None else ''
            self.print("Best result> Fitness (train): {:.6f},{} Neurons: {}, Connections: {}".
                       format(best.fitness, best_test_str, best.genome_neurons, best.genome_connections), override=True)
        else:
            best_tuple = (self.get_current_window() + 1, best.genome_id,
                          best.spawn_gen + 1, self.windows_final_gens[-1], best.fitness,
                          self.best_test.fitness if self.best_test is not None else None,
                          best.genome_neurons, best.genome_connections)
            self.windows_best.append(best_tuple)
            self.print_windows_best()

    def evaluate_best_test(self):
        best = self.get_best()
        if self.test_data is not None:
            self.best_test = self.evaluate_test(best.genome)

    def termination_sequence(self):
        if not self.best_list:
            self.print('Warning: no solution found')
            return

        self.windows_final_gens.append(self.generation)
        # Reevaluate the best individuals with full data if sample_size is specified
        if self.options.sample_size != 0 and not self.options.no_reevaluation:
            self.output_update_state('Full reevaluation')
            self.reevaluate_best_list()

        self.output_update_state('Saving results')
        self.evaluate_best_test()  # Test the best individual obtained with the test data-set
        self.print_best()  # Print to stdout the best result
        self.write_results()  # Write run details to files
        self.save_encoder()  # Save encoder
        self.save_mapping()  # Save encoding mapping

    def shift_window(self):
        self.termination_sequence()

        self.best_list.clear()
        self.best_set.clear()
        self.best_test = None
        self.reset_window_timers()

        self.output_update_state('Shifting window')
        # Prepare new data
        old_columns = self.train_data.input_labels
        self.train_data, test = next(self.slider)
        if test is not None:
            self.test_data = test
        if self.encoder is not None:
            self.encode_data(soft_order=old_columns)
        self.setup_evaluator()

        self._update_inputs(old_columns)

    def _update_inputs(self, old_inputs):
        # Which columns have changed
        new_inputs = util.diff_indexes(old_inputs, self.train_data.input_labels)
        self.n_inputs_diff = len(new_inputs)
        self.n_inputs_delta = self.train_data.n_inputs - len(old_inputs)
        self.inputs_diff_old = [old_inputs[i] for i in new_inputs]
        self.inputs_diff_new = [self.train_data.input_labels[i] for i in new_inputs]
        self.inputs_diff = [(old_inputs[i], self.train_data.input_labels[i]) for i in new_inputs]
        self.inputs_new = self.train_data.input_labels[-self.n_inputs_delta:] if self.n_inputs_delta > 0 else []

        if self.options.method == 'hyperneat':
            # Just update the substrate to match the new number of inputs
            self.substrate = self._init_substrate()
        else:
            # Resize the number of inputs of each individual in the population
            self.pop.ResizeInputs(self.train_data.n_inputs)
            # Remove the old connections of the new inputs
            self.pop.DisconnectInputs(new_inputs)

    def should_shift(self):
        if not self.is_online or not self.slider.has_next():
            return False
        return self.is_window_finished()

    def is_window_finished(self):
        window = self.get_current_window() + 1

        generation_limit = self.options.generations is not None and self.generation >= self.options.generations * window
        time_limit = self.options.time_limit is not None and \
                     self.elapsed_time().total_seconds() / 60 >= self.options.time_limit * window
        return generation_limit or time_limit

    def get_current_window(self):
        return self.slider.get_current_window_index() if self.slider is not None else 0

    def adjust_mutation_rates(self):
        if self.mutation_rate_controller is not None:
            complex_type = self.bloat_options.mutation_options.complexity_type
            if complex_type is bloat.ComplexityType.CONNECTIONS:
                complexity = avg([e.genome_connections for e in self.evaluations])
            elif complex_type is bloat.ComplexityType.NEURONS:
                complexity = avg([e.genome_neurons for e in self.evaluations])
            elif complex_type is bloat.ComplexityType.TIME:
                complexity = (self.gen_ea_time + self.gen_eval_time).total_seconds()
            elif complex_type is bloat.ComplexityType.PREDTIME:
                complexity = avg([e.pred_avg_time for e in self.evaluations])
            else:
                raise NotImplementedError
            self.mutation_rate_controller.adjust(complexity, generation=self.generation)
            self.pop.Parameters = self.mutation_rate_controller.params
            self.params = self.pop.Parameters

    def init_timers(self):
        if not self._keep_timers:
            self.initial_time = datetime.datetime.now()
            self.ea_time = datetime.timedelta()
            self.eval_time = datetime.timedelta()
            self.reset_window_timers()
            self.reset_generation_timers()
        self._keep_timers = True

    def reset_window_timers(self):
        self.window_initial_time = datetime.datetime.now()
        self.window_ea_time = datetime.timedelta()
        self.window_eval_time = datetime.timedelta()

    def reset_generation_timers(self):
        self.gen_ea_time = datetime.timedelta()
        self.gen_eval_time = datetime.timedelta()
        self.gen_initial_time = datetime.datetime.now()

    def _gen_start(self):
        self.print_top10()
        self.reset_generation_timers()

    def _gen_end(self):
        self.adjust_mutation_rates()
        if self.should_shift():
            self.shift_window()
        self.save_progress()

    def _run(self):
        self.init_timers()
        # Run the EA
        while not self.is_finished():
            self._gen_start()
            self.evaluate_pop()
            self.epoch()
            self._gen_end()
        self.termination_sequence()

    def _multiple_runs(self):
        class Summary:
            def __init__(self, runs_list):
                best_run_i, best_run = max(enumerate(runs_list), key=lambda x: x[1].best.fitness)
                self.best_run = best_run_i
                self.best_fitness = best_run.best.fitness
                self.average_fitness = avg([run.best.fitness for run in runs_list])

                if best_run.best.fitness_test is not None:
                    self.best_fitness_test = best_run.best.fitness_test
                    self.average_fitness_test = avg([run.best.fitness_test for run in runs_list])

                run_time_list = [run.run_time for run in runs_list]
                self.average_run_time = sum(run_time_list, datetime.timedelta()) / len(run_time_list)
                self.total_run_time = sum(run_time_list, datetime.timedelta())

        runs_summary_list = []
        for i in range(self.options.runs):
            self.run_i = i
            for line_i in range(len(self.printer)):
                self.printer[line_i] = ''
            self._run()
            runs_summary_list.append(self.get_summary())
            self.clear()

        with open(self.get_out_file_path('summary.json'), 'w', encoding='utf8') as f:
            f.write(json.dumps(Summary(runs_summary_list).__dict__, default=util.serializer, indent=4))

    def run(self):
        reprint.is_atty = reprint.is_atty and self.options.reprint
        if self.options.runs > 1:
            self._multiple_runs()
        else:
            self._run()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.reprint_obj is not None:
            self.reprint_obj.__exit__(exc_type, exc_val, exc_tb)


if __name__ == '__main__':
    options = parse_args()
    with Evolver(options) as evolver:
        evolver.run()
